generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/* === USUARIOS === */

model User {
  id       Int    @id @default(autoincrement())

  // Datos de autenticación
  email    String @unique
  password String

  // Datos personales
  name     String            // nombre completo
  country  String?           // país
  city     String?           // ciudad
  phone    String?           // teléfono

  // Rol y estado
  role     Role      @default(CONSUMER)
  status   UserStatus @default(PENDING)
  active   Boolean @default(true)

  // Organización / unidad (si lo sigues usando)
  orgUnit  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Datasets donde es provider
  datasets Dataset[] @relation("UserDatasets")

  // Contratos como provider y como consumer
  providerContracts Contract[] @relation("ProviderContracts")
  consumerContracts Contract[] @relation("ConsumerContracts")

  // Solicitudes de acceso donde es consumer
  accessRequestsAsConsumer AccessRequest[]

  // Logs de acceso
  accessLogs AccessLog[]

  // Conversaciones de soporte como usuario solicitante
  supportConversationsAsUser     SupportConversation[] @relation("UserSupportConversations")

  // Conversaciones de soporte como operador asignado
  supportConversationsAsOperator SupportConversation[] @relation("OperatorSupportConversations")

  // Mensajes de soporte enviados por este usuario
  supportMessages                SupportMessage[]      @relation("UserSupportMessages")
}

enum Role {
  PROVIDER
  CONSUMER
  OPERATOR
}

enum UserStatus {
  ACTIVE     // usuario aprobado y con acceso normal
  PENDING    // recién registrado, pendiente de aprobación por operador
  REJECTED   // rechazado por operador
  SUSPENDED  // opcional: suspendido temporalmente
}

/* === DATASETS / CATÁLOGO === */

model Dataset {
  id                 Int                 @id @default(autoincrement())
  name               String
  description        String?
  category           String?
  tags               String?
  origin             DatasetOrigin       @default(INTERNAL)
  storageType        DatasetStorageType  @default(FILE)
  storageUri         String?
  published          Boolean             @default(false)
  legalBasis         String?
  dataClassification DataClassification  @default(INTERNAL)
  usageTerms         String?

  providerId Int
  provider   User               @relation("UserDatasets", fields: [providerId], references: [id])

  status      DatasetStatus @default(ACTIVE)
  blocked     Boolean       @default(false) // redundante, pero cómodo en frontend

  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt

  externalDatasetId Int?
  externalDataset   ExternalDataset?   @relation(fields: [externalDatasetId], references: [id])

  accessRequests AccessRequest[]
  contracts      Contract[]
  accessLogs     AccessLog[]
}

enum DatasetStatus {
  ACTIVE    // visible y utilizable
  BLOCKED   // bloqueado por operador
  DRAFT     // opcional (borrador del provider)
}

model ExternalDataset {
  id             Int      @id @default(autoincrement())
  externalSystem String
  externalId     String
  name           String
  description    String?
  metadataJson   String?

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  datasets       Dataset[]
}

enum DatasetOrigin {
  INTERNAL
  EXTERNAL_OPENMETADATA
}

enum DatasetStorageType {
  FILE
  EXTERNAL_API
  DB_VIEW
}

enum DataClassification {
  PUBLIC
  INTERNAL
  CONFIDENTIAL
}

/* === NEGOCIACIÓN Y CONTRATOS === */

model NegotiationType {
  id                      Int       @id @default(autoincrement())
  name                    String
  description             String?
  defaultContractTemplate String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  accessRequests AccessRequest[]
}

model AccessRequest {
  id               Int        @id @default(autoincrement())

  datasetId        Int
  dataset          Dataset    @relation(fields: [datasetId], references: [id])

  consumerId       Int
  consumer         User       @relation(fields: [consumerId], references: [id])

  negotiationTypeId Int?
  negotiationType  NegotiationType? @relation(fields: [negotiationTypeId], references: [id])

  status           AccessRequestStatus @default(PENDING)

  requestedPurpose  String?
  requestedDuration String?     // p.ej. "6 meses"
  requestedScope    String?     // p.ej. "solo columnas X,Y,Z; sin datos personales"

  consumerComment  String?
  providerComment  String?

  agreedDuration   String?     // duración final acordada
  agreedScope      String?     // alcance final acordado
  agreedPurpose    String?     // finalidad final acordada (puede ser igual o ajustada)

  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  approvedAt       DateTime?
  rejectedAt       DateTime?

  contract         Contract?
}

model Contract {
  id             Int       @id @default(autoincrement())

  accessRequestId Int      @unique
  accessRequest   AccessRequest @relation(fields: [accessRequestId], references: [id])

  datasetId      Int
  dataset        Dataset   @relation(fields: [datasetId], references: [id])

  providerId     Int
  provider       User      @relation("ProviderContracts", fields: [providerId], references: [id])

  consumerId     Int
  consumer       User      @relation("ConsumerContracts", fields: [consumerId], references: [id])

  odrlPolicy    Json?

  contractText          String
  technicalConstraintsJson String?

  effectiveFrom DateTime
  effectiveTo   DateTime?
  status        ContractStatus @default(ACTIVE)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  accessLogs    AccessLog[]
}

enum AccessRequestStatus {
  PENDING              // Consumer acaba de solicitar, espera respuesta del Provider
  COUNTER_FROM_PROVIDER // Provider ha hecho contraoferta, espera respuesta del Consumer
  COUNTER_FROM_CONSUMER // Consumer ha ajustado, espera respuesta del Provider
  APPROVED             // Acordado, ya se generó contrato
  REJECTED
  CANCELLED
}

enum ContractStatus {
  ACTIVE
  EXPIRED
  REVOKED
}

/* === AUDITORÍA === */

model AccessLog {
  id         Int      @id @default(autoincrement())

  userId     Int
  user       User     @relation(fields: [userId], references: [id])

  datasetId  Int
  dataset    Dataset  @relation(fields: [datasetId], references: [id])

  contractId Int?
  contract   Contract? @relation(fields: [contractId], references: [id])

  action     AccessAction
  purpose    String?
  ipAddress  String?
  userAgent  String?
  extra      String?

  timestamp  DateTime  @default(now())
}

enum AccessAction {
  VIEW_METADATA
  DOWNLOAD
  API_ACCESS
  POLICY_DENY
}

enum SupportConversationStatus {
  OPEN
  IN_PROGRESS
  CLOSED
}

model SupportConversation {
  id           Int                       @id @default(autoincrement())
  title        String
  status       SupportConversationStatus @default(OPEN)

  // Usuario solicitante (CONSUMER o PROVIDER)
  user         User                      @relation("UserSupportConversations", fields: [userId], references: [id])
  userId       Int

  // Operador asignado (opcional)
  operator     User?                     @relation("OperatorSupportConversations", fields: [operatorId], references: [id])
  operatorId   Int?

  messages     SupportMessage[]

  createdAt    DateTime                  @default(now())
  updatedAt    DateTime                  @updatedAt
}

model SupportMessage {
  id               Int                 @id @default(autoincrement())
  conversation     SupportConversation @relation(fields: [conversationId], references: [id])
  conversationId   Int

  // IMPORTANTE: el nombre de la relación debe coincidir con User.supportMessages
  sender           User                @relation("UserSupportMessages", fields: [senderUserId], references: [id])
  senderUserId     Int

  content          String
  createdAt        DateTime            @default(now())
}